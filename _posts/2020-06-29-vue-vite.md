---
layout: post
title:  "[Vue.js] A note on Vite, the fastest development server of all time!"
date:   2020-06-28 20:09:36 +0100
categories: Vue.js
permalink: /vue/vite-fastest-dev-server
---

Vite (which means ‘fast’ in French) is the new Vue development server based on **ES modules** instead of **bundles**.

Perhaps it doesn’t sound so exciting, said so, but getting rid of the bundling step offers advantages : 
 - a very reduced compilation time
 - on source code update, the possibility of **directly updating** modules that have been modified **instead of re-bundling** all or part of the source-code

Result, the server is worth its name: it is so fast that it **literally updates instantly the browser** on source code update (and of course it retains the state). This definitely can speed up development, especially on big apps, and, honestly, it **dramatically increases front-end developer experience**: bye bye waiting [ rocket]


*Nb: Vue supports HMR, so on update only a part of the app is recompiled into a bundle, and state can be retained. This is already pretty fast but does not compare with Vite, which is instantaneous.*

<br/>
<br/>

### ES modules in browsers (why do we need bundles):

<br/>

#### Before ES modules browser support (2017 / 2018):
<br/>
Before supporting ES modules (or “JS modules” or “ECMAScript modules”), browsers hadn’t any module system. Actually, as you know, before ES6 there was no official module system in JavaScript. This led to great workaround built by the community (CommonJS, AMD, RequireJS…), but none were supported by browsers. 

So the only way to “import” a dependency was to load it via the `<script>` tag: 
```
 <script type="text/javascript" src="/helloWorld.js"></script>
```
It was really limited in comparison with a module system, and made things extremely complicated as soon as there were several scripts which depended on each other (they had to be loaded in the right order, to be reachable from global scope…). And they were imported as regular scripts and not as modules.

*What is the difference between module and regular script? Most important differences are that it has a lexical top-level scope (a variable declared in the module scope is not reachable from the global scope, as it would be the case with a regular script), `this` doesn’t refer to the global `this` (but to `undefined`), and of course the support of `import` and `export` syntaxe.*

On the other hand, front-end frameworks have been supplying module system for long time :
 - with their own system before ES6 (ex: Angular JS scope and dependency injection)
 - with ES6 modules after 2015.

Therefore, **bundlers**, which could understand a module system and compile it into a browser-understandable script, **were the best (only) solution, even for development servers**. But, as we will see right after, **browsers now support the same module system** than most of JavScript frameworks, which gives **much more options**, at least for dev servers.

<br/>

#### Browser static modules implementation:
<br/>
But, since 2018, all major browsers support ES modules. 

This means that now browsers expose ways of importing modules: 

 - with the script tag: we inform the browser that the script loaded is a module giving the **“module” value to the `type` attribute**. This is generally used for importing entry points:
```
<script type="module" src="./main.js"></script>
```

 - with the `import` syntax:
```
import App from “/js/app.js"
```

As with the `script` tag, this triggers an **HTTP request** to load the file `app.js`, which will be by default treated as a module - so in particular it can itself import modules. We can then import easily nested dependencies, which will be loaded layer by layer.

*Nb: as soon as there are few layers of dependencies, module imports can lead to cascade of HTTP requests. Therefore, this **not suitable for production** (for more details on module imports vs bundling you can have a look on [this (src: Google V8)](https://v8.dev/features/modules#performance) )*

An other important specificity of the browser `import` implementation is the module specifier (the module path module): it must be an URL, **bare imports are not supported**.

Then, the browser works like a module handler: any new module is added to a dictionary (a Map) and keyed with its URL. So **any module is imported only once** because, if it is required twice, the browser recognize its specifier and gets it from its storage. These details will be useful to understand how Vite browser updates work.

Then, when all the whole dependency graph has been loaded, modules are instantiated (from the most nested to the top), their exports are made available, and only then the main code will be executed.

<br/>

#### Browser dynamic modules implementation:
<br/>
In accordance with ES6 modules spec, browsers also implement the `import()` method which enables dynamic imports - this method is asynchronous and returns a promise. Dynamically imported modules are added to the module Map, and are treated as regular modules. As we will see, Vite relies on this feature for updates.

So we have seen now that browser and Vue apps share the same module system (with different implementations; we will see now how Vite takes advantage of this.

<br/>
<br/>

### The logic behind Vite:

<br/>

#### Overview:

So, as mentioned previously, Vite **serves ES modules instead bundles**. Concretely how does it work ?

Let’s start with the beginning: the entry point and the entry module (cf Part I.).

```
  <script type="module" src="./main.js"></script>
```
```
// main.js

import { createApp } from '/@modules/vue'
import App from '/App.vue'
import '/index.css?import'

createApp(App).mount('#app')
```

And that’s all: the whole app will be, layer by layer, imported from here as ES module! Also, as you can see, this is extremely close to the main.js file in our source code: here only module specifiers have been changed to be browser compatible!

But there is a problem, we have two types of imports: 
 - Statements importing ES modules: the vue dist / bundle ('/@modules/vue') (nb: of course, only the source code is imported as module, Vite uses .dist bundles for external dependencies)
 - Statements importing things which **are not ES modules**, such as: `.vue` files, CSS stylesheet...

So how does Vite deal with that ?

Here is a major feature of Vite: it **transforms on the fly the required resource into valid modules** (thanks to a "pipe" of plugins performing various code transformations, which in some extend reminds webpack loaders used by Vue). We will have an overview of the "compilation" of Single File Components (SFC) into modules in the next part.

The rest of the process is quite straightforward.

The browser imports, layer by layer, the whole dependency graph (cf Part I.). Then, when everything has been loaded, the browser instantiates from bottom (modules which do not have dependencies) to up (`main.js`) all the modules. So, when the top script `main.js`  is executed, all the dependancies are ready to be used. Then we come back to the standard bootstrap process: the app object is created, which then it mounts the root component, which will recursively mount the rest of the app.

<br/>

#### SFC compilation / transformation:

Concerning SFC, as we mentioned, Vite performs on the run the same kind of code transformation than what the Vue Webpack loader does. As you know, `.vue` files are divided into blocks (`script`, `template`, etc…). Concretely, **Vite transforms each bloc into modules**, which are dependencies of the “script” bloc module.

For this, Vite relies on the Vue Compiler, which, in particular, parses `vue` files into an objects (`FileDescriptor`) and produces render functions.

So, for example, it:
 - transforms templates into a module exporting a render function
 - transforms styles into a module exporting a CSS string
 - extracts the `script` block, which is already a module, and in particular adds statements to import the other blocks

*Nb: Vite supports **TypeScript**, **JSX** and **CSS pre-processors**. It also supports **custom blocks** by allowing user to write its own plugins.*

<br/>
<br/>

### Vite on updates : No bundling, no waiting

Vite, as any other dev server, watches files changes (with a dependency called chokildar). When it detects a change, it emits an event (through a web socket), like this one:
```
{path: "/components/HelloWorld.vue",
timestamp: 1590935911313,
type: "vue-reload"}
```

As you can see, this message contains a file path.

Then, in the event listener (located in the module responsible for opening the web socket, imported as ‘hmr’) : 

```
// hmr
// in case of a type “vue-reload”
        case 'vue-reload':
            import(`${path}?t=${timestamp}`)
                .then((m) => {
                __VUE_HMR_RUNTIME__.reload(path, m.default);
                console.log(`[vite] ${path} reloaded.`);
            })
                .catch((err) => warnFailedFetch(err, path));
            break;
```

So Vite leverages here **ES6 dynamic modules imports** (cf Part I.) and simply imports the updates as modules.

Full code here : https://github.com/vitejs/vite/blob/master/src/client/client.ts

Why is there a timestamp in the URL passed to the `import` function ?
Because browsers register modules into a Map where they are keyed by URL. So, if we passed only the URL to the `import` function, the browser would recognize it and it would directly return the module which has been stored during the bootstrap of the app.

Then, the we come back to a standard behaviour: the imported module is passed either to a Vue dependency ( `__VUE_HMR_RUNTIME__`), which will update the virtual DOM, or, in case of CSS updates, will directly update the DOM.

But what happens when the updated component has dependencies, and presents import statements ? Are they re-imported as well ?

Of course not, and here again Vite takes advantage of ES modules: when it returns an updated component, it doesn’t change the URL of dependencies, which have not been updated. Since the browser recognizes these module specifiers of the dependencies, it will fetch in its module cache instead of triggering an HTTP request.
