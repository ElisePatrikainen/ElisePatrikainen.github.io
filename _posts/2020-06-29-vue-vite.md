---
layout: post
title:  "[Vue.js] A note on Vite, an unbundled development server"
date:   2020-07-11 16:09:36 +0100
categories: Vue.js
permalink: /vue/vite-fastest-dev-server
image: /assets/images/viteImage.PNG
---
![SFC imports shema](/assets/images/viteImage.PNG)
<span style="text-align: center; font-size: 14px; font-style: italic">Photo by <a href="https://unsplash.com/@mariocalvo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Mario Calvo</a> on <a href="https://unsplash.com/s/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>

<br/>

Vite is the brand new development server proposed by the Vue framework. This is a small **breakthrough** because it is the **first development server** associated with a main front-end framework that **doesn't use bundles** in development mode. Indeed, it uses ES module (or “JS modules” or “ECMAScript modules”) instead. Therefore, when a modification is made to the source code, Vite **updates the app in our browser instantaneously**.

> Nb: Vite still uses bundles for production (based on Rollup, which itself is based on ES modules)

The server is so fast that it gives a sensation similar to when we, for example, change some style directly in the browser's console, which seriously improves front end developer experience by freeing us from waiting 🤘. 

> Vite means 'fast' in French

In addition to this, if Vite is primarily designed to work with Vue, it is **framework agnostic** and can be adapted through plugins (it already works with **React**, cf IV. C.).

So how does this technological wonder works?

<span style="color: red; font-style: italic">[Diclaimer: the three first partsa consistent part of this article give an overview of Vite's concepts and how Vite works, but are absolutely not needed to use Vite. **The user in a hurry can go directly to the parts II and IV**, which present Vite's main features and gives some elements on how to "migrate" to Vite.]</span>



### I. [Reminders] Core concepts:

#### A. Bundled vs unbundled development:

Here are two terms which have been coined / popularised (I think) by @FredKSchott. You can find [here](https://www.snowpack.dev/#unbundled-development) his definition, which I summarize here:
- 'bundled development' is the process we cope with every day: the source code, which is not directly understandable by browsers, is compilled and bundled. The main reason for bundling is that browsers do not understand modules formats used in the source code (cf B.), so we have to concatene everything into huge scripts. The painpoint here is that, for any modification done in the source code, part or all of the application has to be rebuilt, which takes time \*.
- 'unbundled development' is the idea that, since we have now an official module system in JavaScript, everybody can understand each other and we can skip the bundling process. The interesting thing is that, on source code modification, we do not need to rebuild everything, but to compile (if needed) and ship only the modules affected by the modification. And **this takes few miliseconds**.

*\* Assuming that, when I work, I test my development every 5 minutes on average, that rebundling takes 2 seconds, that I do not loose the state of my app in between: (2x12x7x5x49) / 3600 = 11,43 hours per year that dedicated to bundling process. If I change the rebuild time to 10 seconds, it makes 2 days and 3 hours.*



#### B. Why bundled development?

This is a bit next to the subject, but I think it is a legitimate question: **why have we been imposing this to front-end developers for years?**

First thing we can note is that, before supporting ES modules (so until late 2017 for Chrome, early 2020 for Edge), **browsers did not implement any standard module system.** So source code, which was modularized, had to be bundled for browsers.
> By implementing a 'module system', I mean:
- supporting a module format
- implementating a module loader

Could have the community provide a browser friendly module system then?

Probably, if there had not been a bigger problem behind: until ES6, there was **no official module format in JavaScript**. This, fortunately, did not prevent the community to use module pattern, by creating its own module format. The thing is that it did not create one, but numerous ones: CommonJS (CJS), Asynchronous Module Definition (AMD, Universal Module Definition (UMD). Plus [Global](https://medium.com/@trek/last-week-i-had-a-small-meltdown-on-twitter-about-npms-future-plans-around-front-end-packaging-b424dd8d367a) (in the end, the only universal available format). Plus frameworks using their own module systems (Angular JS scope and dependency injection). All these were great workarounds, but had the major inconvenient of being more numerous than 1. 

> for node.js environment, CJS has been imposed from the beginning, so this problem is purely front-end.

Why did not one 'won' over others? CJS was not browser-friendly. AMD was browser friendly, and had browser compatible loaders ([require.js](https://requirejs.org/), [curl.js](https://github.com/cujojs/curl)) but dependency management was difficult to configure. I guess UMD came too late.

Therefore, it has been commonly aggreed that the best solution was to use a bundler (namely Webpack) which could understand all module formats and compile it into a good old script. 


#### C. Browser ES modules implementation:

Here we are: all major browsers (excepted IE) support ES modules!

> Here is a reminder on the most important **differences between modules and regular script** (this is not exhaustive):
 -  a module has a lexical top-level scope (a variable declared in the module scope is not reachable from the global scope, as it would be the case with a regular script)
 - in a module, `this` doesn’t refer to the global `this` (but to `undefined`)
 - of course, a module supports `import` and `export` syntax

Browsers expose two ways of handling static imports:
- with **the `script` tag**, by giving the new **`module` value** to the `type` attribute (generally used for **entry points**): 
 ```
 <script type="module" src="./main.js"></script>
 ```
- with **the `import` syntax** (the script loaded will be by default treated as a module):
```
import App from “/js/app.js"
``` 

Both of them triggers an **HTTP request** to load the file `app.js`. In particular, the `import` syntax lets us easily import **nested dependencies**, which will be loaded layer by layer.

> As soon as there are few layers of dependencies, module imports can lead to a cascade of HTTP requests. Therefore, this **not suitable for production** (more details on this [here (src: Google V8)](https://v8.dev/features/modules#performance) )

An important specificity of the browser `import` implementation is the module specifier (the module path module): it must be an URL, **bare imports are not supported**.

Then, the browser works like a **standard module loader**: any new module fetch is added to a dictionary where it is keyed by URL. An important thing to notice though is that **any module is imported only once** (if it is required twice, the browser recognizes its specifier and gets it from its storage). This point will be useful to understand how Vite updates browser on source code change.

Then, when all the whole dependency graph has been loaded, modules are instantiated (from the most nested to the top), their exports are made available, and only then the most up code will be executed.

Following ES modules specs, browsers also implement the `import()` method which enables **dynamic imports** - this method is asynchronous and returns a promise:

```
import("/js/app.js)".then((m) => { // use module })
``` 

Dynamically imported modules are added to the dictionary containing other modules and instanciated, and then can be used as regular modules. As we will see, **Vite relies on this feature for updates**.

> For more information browser ES module implementation, please have a look at [this awesome in-depth article](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/) from the Mozilla Team on how this works internally.


#### D. Unbundled development:

With the implementation of ES modules, ES based servers appeared: [ES dev server](https://open-wc.org/developing/es-dev-server.html), Snowpack, Vite.

So how Vite differs from SP (cf tweet):
- Vue built-in support
- built-in production mode with Rollup / SP uses Webpack via plugin


### II. Vite's features:

*This part is much inpired from [this tweet](https://twitter.com/youyuxi/status/1258063980473528331?) from Evan You.*

#### A. Generalities:

Vite is a development server based on ES modules and a production server based on the bundler Rollup (which itself is based on ES modules). Even though Vite has built-in support for Vue apps (this point is being discussed [here](https://github.com/vitejs/vite/issues/576)), Vite is framework agnostic, and can support other frameworks with plugins. It currently has a working plugin for Vue, React, Preact and Svelte.

Also, Vite is customizable by adding a [`vite.config.(j|t)s`](https://github.com/vitejs/vite/blob/master/src/node/config.ts#L306) to the project. The file (ESM or CJS) has to export an object whose type is defined [here](https://github.com/vitejs/vite/blob/master/src/node/config.ts#L305). We will see examples in B and C.


#### B. On development:

As seen in I. A and D, Vite serves source files "directly" via ES modules, without a bundling step. To be able to do this, Vite can compile **on the fly** several kind of files into ES modules:
- Vue's SFC
- resources such as CSS files or assets, which, like with Webpack, can be directly imported in JS code. About CSS, Vite supports CSS pre-processors and PostCSS
- TypeScript and JSX files 

Vite handles this via a series of Koa middlewares, which look a bit like Webpack loaders. 

> Vite is built with the framework Koa

Vite supports HMR (Hot Module Replacement) for Vue and React apps (with the `vite-plugin-react`). Thanks to this, on source code change, Vite only updates in browser modules which have been changed instead of reloading the page. Combined with unbunded development, this is the key which makes Vite's magic (cf III.).

**Customization:** 
- to handle custom files transformation, [koa middleware](https://github.com/vitejs/vite/blob/master/src/node/config.ts#L71) can be added to the config file (cf A)
- for SFC, to add a custom block plugin, a [transform function](https://github.com/vitejs/vite/blob/master/src/node/config.ts#L118) ( `code => trasformedCode`) has to be added to the config file 
- to add HMR support for other frameworks, an [API](https://github.com/vitejs/vite#hot-module-replacement) is available


#### C. On production:

Vite relies on Rollup, which is based on ESM. It is already configured to 'mirror the dev server'. 

**Customization:** 
- [custom Rollup plugins](https://github.com/vitejs/vite/blob/master/src/node/config.ts#L306) can be added to the config file


#### D. External dependancies:

This is an important point: Vite only handles dependencies which **provide a distribution in ES format**. If not, Vite will just not find the module and return an error on the request for the module exported by the package.

// the error

This might be **the most serious problem for migrating an existing application to Vite** because, even if ES distributions should be, at some point, the norm, currently many packages do not provide it (cf I. B and III. A.). 

This raises a question: **will Vite choose to support other formats than ESM** (as snowpack?)? According to this [issue](https://github.com/vitejs/vite-plugin-react/issues/15#issuecomment-661578986), it will not, because it would require to implement a dubious solution.

Indeed, a non-ES module may rely on some dynamic logic which is difficult for ESM bundlers (such as Rollup, which is used by Vite) to analyze. Therefore, with for example Rollup, a non-ES module can be transpilled into ESM:
- in a single export, which can be done cleanely and easily (with `@rollup/plugin-commonjs`)
- in several exports, which then requires some kind of tricky 'hack' (according to the issue, 'Babel transforms + runtime interop helpers')
The problem is that we generally need the 'several exports' version. For example, in React, even if React distibution is not available in ESM, we can do this: `import {x} from 'React'`. So Vite, to handle that, would have to implement the dicey solution described above.

Therefore the team choose to rather support ES distributions, which is the cleanest option of all.

> For React, the team recommands to use the ESM React builds `@pika/react` and `@pika/react-dom` (cf IV. C.)


#### E. Others:

For now, ES linting + testing are out of the scope of Vite. 



### II. The logic behind Vite:


#### A. Unbundled development in practice:

To better apprehend how **unbundled development makes things easy**, I think the best is to view it. A good example is the entry point (which is also the top level script) of the app. Here is a copy of what is served to the browser by Vite:

```
  <script type="module" src="./main.js"></script>
```
```
// main.js

import { createApp } from '/@modules/vue'
import App from '/App.vue'
import '/index.css?import'

createApp(App).mount('#app')
```

And that’s all.

**The whole source code and external dependencies** will be, layer by layer, **imported from here** through module imports (a cascade of HTTP requests). Also, as you can see, this is extremely close to the main.js file in our source code: here only module specifiers have been changed to be browser compatible (cf I. C.);

The browser imports, **layer by layer, the whole dependency graph** (cf Part I.). Then, when everything has been loaded, the browser **instantiates** from bottom (modules which do not have dependencies) to up (`main.js`) all the modules. So, when the **top script `main.js`** is executed, all **the dependencies are ready** to be used. Then we come back to the **standard bootstrap process**: the root Vue instance is created, which, in the process, recursively mounts all components (which have already been instantiated).
 (meaning?)

How can this work?
To figure this, one important things to notice is that the dependancy graph is fully updated and modules are instanciatedc before this script is executed. Therefore, this is *somehow* similar, at this point, as if we had loaded the variables through script which had simulated modules (as in Webpack?) + stocked into variables.


#### B. Nested dependancies management:

An important part of Vite's job is to rewrite modules imports before serving them. Indeed:
- browsers don't understand bare imports (cf I. C), they need something more like an URL; but we use generally bare imports in source code since they are supported by bundlers => vite has to change that
- dependencies of nested dependencies have 'nested' URL / module specifiers. Since Vite has a stateless (HTTP) API, it doesn't know that relative module specifiers have to be rewritten to absolute module specifiers. 

> In the case where the dependency is modularized (not 'bundled' into one big ES export) this can lead to very numerous HTTP requests, which is not a problem in a development environment.



#### E. Example: SFC compilation & transpilation:

Concerning SFC, as we mentioned, Vite performs on the run the same kind of code transformation than what the **Vue Webpack loader** does. As you know, `.vue` files are divided into blocks (`script`, `template`, etc…). Concretely, Vite **transforms each bloc into modules**, which are dependencies of the “script” bloc module.

For this, Vite relies on **the Vue Compiler**, which, in particular, **parses `vue` files** into objects (`FileDescriptor`) and produces **render functions**.

Here are the main steps of this process:

- when the server gets a request matching the pattern `/<componentName>.vue`, it first extracts **the `script` block**, performs the transformations described above, adds style and template imports, adds callbacks to handle these imports and returns the module
- then the **style block** is compiled into a **CSS string**, wrapped into a module and returned
> once loaded, it is handled by the module previously imported, and will **update** directly **the DOM** (via DOM API) through the function `updateStyle`(also added to the first module by Vite)
- then the **template block** is compiled into a **render function**, wrapped into a module and returned
> once loaded, it is appended to the component instance under the `render` property


This schema summarizes the steps described above:
![SFC imports shema](/assets/images/SFCImport.PNG)


### III. Vite's magic: instantaneous browser updates


#### A. Vite re-imports only the modules where a modification has been made:

Vite, like any other dev server, watches files. When it detects that a file has been modified, it emits an event (through a web socket), like this one:
```
{path: "/components/HelloWorld.vue",
timestamp: 1590935911313,
type: "vue-reload"}
```

As you can see, this message contains a **file path**. This is the **module specifier of the module to update**.

Then, in the event listener (located in the script responsible for opening the web socket, imported as ‘hmr’) : 

```
// hmr
// in case of a type “vue-reload”
        case 'vue-reload':
            import(`${path}?t=${timestamp}`)
                .then((m) => {
                __VUE_HMR_RUNTIME__.reload(path, m.default);
                console.log(`[vite] ${path} reloaded.`);
            })
                .catch((err) => warnFailedFetch(err, path));
            break;
```
*[Here](https://github.com/vitejs/vite/blob/master/src/client/client.ts) is the source code.*

Vite leverages here **ES6 dynamic modules imports** (cf Part I.) and imports directly the modules containing the update. 

So, in addition to **skipping any bundling process**, thanks to the granularity offered by the module system, it can **reload precisely only the very piece of code updated**.

> Why is there a **timestamp in the URL** passed to the `import` function?
Because browsers **register** modules into a dictionary where they are **keyed by URL**. So, if we passed only the URL to the `import` function, the browser would recognize it and it would directly return the module which has been stored during the bootstrapping of the app.

Then, we come back to a **standard behavior**: the imported module is passed either to a Vue dependency ( `__VUE_HMR_RUNTIME__`), which, as its name implies, handles HMR, and which will update the virtual DOM, or, in case of CSS updates, will directly update the DOM.

Simple and efficient!

![Vite updates shema](/assets/images/viteUpdatesShema.PNG)


#### B. No dependency is re-imported:

But what happens when the updated component has dependencies and presents import statements? Are they re-imported as well?

Of course not, and here **again Vite takes advantage of ES modules**: when it returns an updated module, it doesn’t change the URL of its dependencies. Since **the browser recognizes the module specifiers** of the dependencies, it will fetch these modules in its cache instead of triggering HTTP requests to import them.

> And what if a module is modified and one of its dependencies at the same time? These modifications are handled in two different sequences (two distinct events are emitted).


### IV. How can I 'migrate' my app to use Vite?

#### A. For any app:

Even though Vite is primarily designed to work with Vue, it is framework agnostic, and can be 'customized' to other frameworks through plugins. For example, it has already a workable plugin for React (cf IV. C.). But, plugins apart, there are some operation to perfom which are common to any migration, which are described bellow.

1. Obviously, a first common step is to add Vite :D :
```
yarn add --dev vite
```

2. <span style="font-weight: bold; color: red">[Diclaimer: this is the biggest painpoint in the migration process]</span> Change all **dependancies distributions** to **ES modules**. Indeed nowadays, most NPM packages are exported in CJS and/or in AMD, and unfortunaltely not all of them provide ES builds. But Vite, for now, only supports ES modules, and will not find, for example, a dependancy with a CJS distribution (cf II. C.).

Example: Lodash

Let's say we have imported Lodash in our project: 
```
  "dependencies": {
    "lodash": "^4.17.19"
  },
```
And we use it in our code:

```
import {cloneDeep} from 'lodash'

const a = {toto: 3}
const b = cloneDeep(a);
```
Then Vite throws an error:

```
```
Why does this happen ? Because Lodash standard distribution format is CSJ, which do not suit with Vite.

> But how can this usually work since we import here something with the 'import' instruction (instead of 'require') ? Well, usually Webpack handles this, probably by transpilling the source code into CJS (or opposite ?) [to check]

Fortunately, Lodash provides ES build. Actually not in npm, but one can generate it through the CLI. This adds a bit of complexity though because this manual export needs to be kept manually updated. This shows that, even for a widely used library as Lodash, using ES builds is not as convenient as other distributions. 

Anyways, ES distributions shall become the norm soon, so this problem will resolve at some point. But until then, this poses problems / todo:  il faut ruser :( 


**Production:**

Not much to add about production, since a production mode is already integrated and configured in Vite. You may just need to move the `index.html` (or your entry point) in the root folder, or to configure the entry point for Rollup to find it. 

Also, Rollup configuration is available: ...

#### B. Vue app:

In the case of a Vue app, here are the steps to do (in addition to the steps exposed in A.):

<ol start=3>
<li>Since Vite is only compatible with Vue 3, first thing is (if needed) to upgrade to Vue 3. For this, you can run the following Vue CLI plugin:

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>vue add vue-next
</code></pre></div></div>
</li>

<li>
[optional] you can remove CLI packages. But, if you are using some CLI feature with are not supllied by Vite (see **running tests** below), you may want to keep this package:
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>yarn remove @vue/cli-service
</code></pre></div></div>
</li>

<li>change the `scripts` in `package.json`:
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"scripts": {
<span class="changed-code removed-code">-      "serve": "vue-cli-service serve",</span>
<span class="changed-code removed-code">-      "build": "vue-cli-service build",</span>
<span class="changed-code added-code">+      "dev": "vite",</span>
<span class="changed-code added-code">+      "build": "vite build"</span>
},
</code></pre></div></div>
</li>

<li>(this is conditioned with your entry point - here we use the entry point generated by the Vue CLI) connect the entry point (`index.html`) with the scripts, remove all that is related with Webpack:

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><!DOCTYPE html>
&lt;html lang="en">
  &lt;head>
    &lt;meta charset="utf-8">
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge">
    &lt;meta name="viewport" content="width=device-width,initial-scale=1.0">
<span class="changed-code removed-code">-    &lt;link rel="icon" href="<%= BASE_URL %>favicon.ico"></span>
<span class="changed-code removed-code">-    &lt;title><%= htmlWebpackPlugin.options.title %>&lt;/title></span>
<span class="changed-code added-code">+    &lt;link rel="icon" href="/favicon.ico"></span>
<span class="changed-code added-code">+    &lt;title>My new Vite app!&lt;/title></span>
  &lt;/head>
  &lt;body>
    &lt;noscript>
      &lt;strong>We're sorry but ....&lt;/strong>
    &lt;/noscript>
    &lt;div id="app">&lt;/div>
<span class="changed-code removed-code">-    &lt;!-- built files will be auto injected --></span>
<span class="changed-code added-code">+    &lt;script type="module" src="/src/main.js">&lt;/script></span>
  &lt;/body>
</html>
</code></pre></div></div>
</li>

</ol>

I guess there will at some point a Vite plugin to handle these little hacks (from step 4).

**Running tests:**
Vue CLI has plugins dedicated to running unit and end-to-end tests (`@vue/cli-plugin-unit-jest`, `@vue/cli-plugin-e2e-nightwatch`...), whereas Vite doesn't offer yet any 'test' plugin. So one would consist in keeping the CLI package to run tests. But, AFAIK, **currently** these plugins do not work well with Vue 3. So, **for now**, I would advise not to use the plugins, but to manually configure test dependencies (Jest, etc), and to run them via the dependencies binaries.  


#### B. React app:

<ol start=3>
<li>[important] Since React is distributed in UMD, and not in ESM (cf I.B), we have to use an ESM build.

> `@pika/react` and `@pika/react-dom` by @FredKSchott (SnowPack) automatically parse React builds to output them in ES modules. The repo checks dayly for React updates, so it is always up-to-date. 

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>"dependencies": {
<span class="changed-code removed-code">-      "react-dom": "^16.13.1",</span>
<span class="changed-code removed-code">-      "react-dom": "^16.13.1",</span>
<span class="changed-code added-code">+      "@pika/react": "^16.13.1",</span>
<span class="changed-code added-code">+      "@pika/react-dom": "^16.13.1"</span>
  },
</code></pre></div></div>
</li>

<li><span style="font-weight: bold; color: red">[this might be limitating]</span>You may have to remove some React dependencies which are not covered by @pika/react:

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>"dependencies": {
<span class="changed-code removed-code">-      "react-dom": "^16.13.1",</span>
<span class="changed-code removed-code">-      "react-dom": "^16.13.1",</span>
<span class="changed-code added-code">+      "@pika/react": "^16.13.1",</span>
<span class="changed-code added-code">+      "@pika/react-dom": "^16.13.1"</span>
  },
</code></pre></div></div>
</li>
</ol>

### Summary:

Vite is a development server based on **ES modules** instead of **bundles**. Thanks to this, Vite can update, on source code change, a Vue app in browser instantaneously by directly **updating modules** that have been modified (with a negligible compilation -or transpilation- time), **instead of re-bundling** all or part of the source code.

To achieve this, Vite compiles all the resources into ES module **on the fly**. In particular, for SFC, it transforms each bloc into a module, relying on the **Vue compiler**.

If this is, of course, only valuable for a development environment (because of the HTTP requests cascade), Vite also offers a production build (based on Rollup), therefore it can be **used on all stages** of a project. For now, Vite is still **experimental**, hence we are looking forward to future developments, and, perhaps, an integration in Vue apps standard configuration. But there is no doubt on one thing: **this will definitely improve front-end experience**.
