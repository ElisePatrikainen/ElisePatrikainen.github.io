---
layout: post
title:  "[Vue.js] A note on Vite, the fastest development server of all time!"
date:   2020-07-11 16:09:36 +0100
categories: Vue.js
permalink: /vue/vite-fastest-dev-server
---

Vite is the brand new development server proposed by the Vue framework - which can be used instead of the Vue CLI. This is a small **breakthrough** because it is the **first development server** associated with a main front-end framework that **doesn't use bundles**. Indeed, it uses ES module instead, on which, to some extend, relies Vue. Therefore, when a modification is made to the source code, Vite **updates the app in our browser instantaneously**. Also, the **state** of the app is retained (like with HMR, see below). 

The server is so fast that it gives a sensation similar to when we, for example, change some style directly in the browser's console, which seriously improves front end developer experience by freeing us from waiting ü§ò. 

> Vite means 'fast' in French

> **Vue supports HMR**, so on update, only a part of the app is recompiled into a bundle, and state can be retained. This is already pretty fast but does not compare with Vite, which is instantaneous.



### I. ES modules in browsers:


#### A. Before ES modules browser support, bundles were the best option:

Before supporting ES modules (or ‚ÄúJS modules‚Äù or ‚ÄúECMAScript modules‚Äù), so until 2017 / 2018, **browsers hadn‚Äôt any module system**. Actually, as you know, before ES6 there was **no official module system in JavaScript**. This led to great workarounds built by the community (CommonJS, AMD, RequireJS‚Ä¶), but none were supported by browsers. 

So the **only way** to 'import' a script was to load it via **the `<script>` tag**: 
```
 <script type="text/javascript" src="/helloWorld.js"></script>
```
It was considerably limited in comparison with a module system, and made things extremely **complicated** as soon as scripts **had dependencies** (they had to be loaded in the right order, to be reachable from global scope‚Ä¶). And they were imported **as regular scripts and not as modules**.

 > Most important **differences between modules and regular script** are that:
 -  a module has a lexical top-level scope (a variable declared in the module scope is not reachable from the global scope, as it would be the case with a regular script)
 - in a module, `this` doesn‚Äôt refer to the global `this` (but to `undefined`)
 - of course, a module supports `import` and `export` syntax

On the other hand, **front-end frameworks** have been **using module systems** for a long time :
 - their own system before ES6 (ex: Angular JS scope and dependency injection)
 - ES modules after 2015

Therefore, **bundlers**, which could understand a module system and compile it into a browser-understandable script, **were**, from far, **the best solution**, even for development servers. But, as we will see right now, **browsers share now the same module system** than most of JavaScript frameworks, which, at least for development environment, gives new possibilities.


#### B. Browser static modules implementation:

But, since 2018, all major browsers (excepted IE) support ES modules. 

This means that now browsers can import modules. The first way is to use the 'good old' **the `script` tag**: 
 ```
 <script type="module" src="./main.js"></script>
 ```
But, to inform the browser that the script loaded **is a module**, we must give the new **`module` value** to the `type` attribute. This is generally used for importing **entry points**.


The second way is to use **the `import` syntax**:
```
import App from ‚Äú/js/app.js"
```

As with the `script` tag, this triggers an **HTTP request** to load the file `app.js`, which will be by default treated as a module - so in particular it can itself import modules. We can then import easily **nested dependencies**, which will be loaded layer by layer.

> As soon as there are few layers of dependencies, module imports can lead to a cascade of HTTP requests. Therefore, this **not suitable for production** (for more details on module imports vs bundling you can have a look on [this (src: Google V8)](https://v8.dev/features/modules#performance) )

Another important specificity of the browser `import` implementation is the module specifier (the module path module): it must be an URL, **bare imports are not supported**.

Then, the browser works like a **standard module handler**: any new module fetch is added to a dictionary where it is keyed by URL. An important thing to notice though is that **any module is imported only once** (if it is required twice, the browser recognizes its specifier and gets it from its storage). This point will be useful to understand how Vite browser updates work.

Then, when all the whole dependency graph has been loaded, modules are instantiated (from the most nested to the top), their exports are made available, and only then the most up code will be executed.


#### C. Browser dynamic modules implementation:

Following ES modules specs, browsers also implement the `import()` method which enables dynamic imports - this method is asynchronous and returns a promise. Dynamically imported modules are added to the dictionary containing other modules and can be used as soon as they are instantiated. As we will see, **Vite relies on this feature for updates**.

So we have seen now that browser and Vue apps share the same module system - with different implementations; we will see now how Vite takes advantage of this.

> For more information browser ES module implementation, please have a look at [this awesome in-depth article](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/) from the Mozilla Team on how this works internally.

### II. The logic behind Vite:


#### A. Overview:

So, as mentioned previously, Vite **serves ES modules instead of bundles**. Concretely how does it work?

Let‚Äôs start with the beginning, the entry point and the entry module (cf Part I.):

```
  <script type="module" src="./main.js"></script>
```
```
// main.js

import { createApp } from '/@modules/vue'
import App from '/App.vue'
import '/index.css?import'

createApp(App).mount('#app')
```

And that‚Äôs all: **the whole app** will be, layer by layer, **imported from here as ES module**! Also, as you can see, this is extremely close to the main.js file in our source code: here only module specifiers have been changed to be browser compatible!

But there is a problem, we have two types of imports: 
 - Statements importing ES modules: the Vue bundle (`/@modules/vue`) 
 > Of course, only the source code is imported as modules, Vite uses the available bundles for dependencies!
 - Statements importing 'things' which **are not ES modules**, such as: `.vue` files, CSS stylesheet...

So how does Vite deal with that?

Here is a major feature of Vite: it **transforms on the fly the required resource into valid modules** thanks to a "pipe" of plugins performing various code transformations (which to some extend reminds Webpack loaders used by Vue).
> There will be **more information** on this **in the next part**, which presents an overview of the compilation / transpilation of **Single File Components (SFC) into modules**.

The rest of the process is quite straightforward.

The browser imports, **layer by layer, the whole dependency graph** (cf Part I.). Then, when everything has been loaded, the browser **instantiates** from bottom (modules which do not have dependencies) to up (`main.js`) all the modules. So, when the **top script `main.js`** is executed, all **the dependencies are ready** to be used. Then we come back to the **standard bootstrap process**: the root Vue instance is created, which, in the process, recursively mounts all components (which have already been instantiated).


#### B. SFC compilation / transpilation:

Concerning SFC, as we mentioned, Vite performs on the run the same kind of code transformation than what the **Vue Webpack loader** does. As you know, `.vue` files are divided into blocks (`script`, `template`, etc‚Ä¶). Concretely, Vite **transforms each bloc into modules**, which are dependencies of the ‚Äúscript‚Äù bloc module.

For this, Vite relies on **the Vue Compiler**, which, in particular, **parses `vue` files** into objects (`FileDescriptor`) and produces **render functions**.

Here are the main steps of this process:

- when the server gets a request matching the pattern `/<componentName>.vue`, it first extracts **the `script` block**, which is already a module, performs few transformations (in particular **adds statements** to import and handle the other blocks) and returns the module
- the **style block** is then loaded through an import (initial module specifier + `type=style`). Here, same process, Vite extracts the `style` block, which is then compiled by Vite into a CSS string. Once loaded, it is handled by the module previously imported, and will **update** directly **the DOM** (via DOM API) through the function `updateStyle`(also added to the first module by Vite)
- the **template block** (module specifier + `?type=template`) is finally imported. It has been **compiled on the fly** by Vite into a **render function**, which is then added to the component.

> Vite supports **TypeScript**, **JSX** and **CSS pre-processors**, for which compilation also happens on the fly, during the process described above. It also supports **custom blocks** by allowing users to write their own plugins (more on this coming here soon.)

This schema summarizes the steps described above:
![SFC imports shema](/assets/images/SFCImport.PNG)




### III. How does Vite performs instantaneous browser updates?


#### A. Vite re-imports only the modules where a modification has been made:

Vite, like any other dev server, watches files. When it detects that a file has been modified, it emits an event (through a web socket), like this one:
```
{path: "/components/HelloWorld.vue",
timestamp: 1590935911313,
type: "vue-reload"}
```

As you can see, this message contains a **file path**. This is the **module specifier of the module to update**.

Then, in the event listener (located in the script responsible for opening the web socket, imported as ‚Äòhmr‚Äô) : 

```
// hmr
// in case of a type ‚Äúvue-reload‚Äù
        case 'vue-reload':
            import(`${path}?t=${timestamp}`)
                .then((m) => {
                __VUE_HMR_RUNTIME__.reload(path, m.default);
                console.log(`[vite] ${path} reloaded.`);
            })
                .catch((err) => warnFailedFetch(err, path));
            break;
```
*[Here](https://github.com/vitejs/vite/blob/master/src/client/client.ts) is the source code.*

Vite leverages here **ES6 dynamic modules imports** (cf Part I.) and imports directly the modules containing the update. 

So, in addition to **skipping any bundling process**, thanks to the granularity offered by the module system, it can **reload precisely only the very piece of code updated**.

> Why is there a **timestamp in the URL** passed to the `import` function?
Because browsers **register** modules into a dictionary where they are **keyed by URL**. So, if we passed only the URL to the `import` function, the browser would recognize it and it would directly return the module which has been stored during the bootstrapping of the app.

Then, we come back to a **standard behavior**: the imported module is passed either to a Vue dependency ( `__VUE_HMR_RUNTIME__`), which will update the virtual DOM, or, in case of CSS updates, will directly update the DOM.

Simple and efficient!

![Vite updates shema](/assets/images/viteUpdatesShema.PNG)


#### B. No dependency is re-imported:

But what happens when the updated component has dependencies and presents import statements? Are they re-imported as well?

Of course not, and here **again Vite takes advantage of ES modules**: when it returns an updated module, it doesn‚Äôt change the URL of its dependencies. Since **the browser recognizes the module specifiers** of the dependencies, it will fetch these modules in its cache instead of triggering HTTP requests to import them.

> And what if a module is modified and one of its dependencies at the same time? These modifications are handled in two different sequences (two distinct events are emitted).


### IV. So how can I migrate my Vue app to use Vite?

Unfortunately, Vite doesn't offer currently any way 'out of the box' to 'migrate' an existing app from the Vue CLI to Vite. Also, Vite is compatible with **Vue 3** only. Maybe the Vue team will choose to "replace" the Vue CLI by Vite into a future Vue release, at least for new projects. Anyways, **as soon as more information is available, this will be updated here**. 

Also, there will be more information on Vite configuration, and on features where the behavior is not completely similar to the one of the Vue CLI (eg: worker configuration).

### Summary:

Vite is a development server based on **ES modules** instead of **bundles**. Thanks to this, Vite can update, on source code change, a Vue app in browser the possibility of **directly updating** modules that have been modified (with a negligible compilation (or transpilation) time), **instead of re-bundling** all or part of the source code.

To achieve this, Vite compiles all the resources into ES module **on the fly**. In particular, for SFC, it transforms each bloc into a module, relying on the **Vue compiler**.

If this is, of course, only valuable for a development environment (because of the HTTP requests cascade), Vite also offers a production build (based on Rollup), therefore it can be **used on all stages** of a project. For now, Vite is still **experimental**, hence we are looking forward to future developments, and, perhaps, an integration in Vue apps standard configuration. But there is no doubt on one thing: **this will definitely improve front-end experience**.
