---
layout: post
title:  "[Vue.js] A note on Vite, the fastest development server of all time!"
date:   2020-06-28 20:09:36 +0100
categories: Vue.js
permalink: /vue/vite-fastest-dev-server
---

Vite (which means ‘fast’ in French) is the new Vue development server based on **ES modules** instead of **bundles**.

Perhaps it doesn’t sound so exciting, said so, but getting rid of the bundling step offers advantages : 
 - a very reduced compilation time
 - on source code update, the possibility of **directly updating** modules that have been modified **instead of re-bundling** all or part of the source-code

Result, the server is worth its name: it is so fast that it **literally updates instantly the browser** on source code update (and of course it retains the state). This definitely can speed up development, especially on big apps, and, honestly, it **dramatically increases front-end developer experience**: bye bye waiting [ rocket]


*Nb: Vue supports HMR, so on update only a part of the app is recompiled into a bundle, and state can be retained. This is already pretty fast but does not compare with Vite, which is instantaneous.*

<br/>
<br/>

### ES modules in browsers (why do we need bundles):

<br/>

#### Before ES modules browser support (2017 / 2018):
<br/>
Before supporting ES modules (or “JS modules” or “ECMAScript modules”), browsers hadn’t any module system. Actually, as you know, before ES6 there was no official module system in JavaScript. This led to great workaround built by the community (CommonJS, AMD, RequireJS…), but none were supported by browsers. 

So the only way to “import” a dependency was to load it via the `<script>` tag: 
```
 <script type="text/javascript" src="/helloWorld.js"></script>
```
It was really limited in comparison with a module system, and made things extremely complicated as soon as there were several scripts which depended on each other (they had to be loaded in the right order, to be reachable from global scope…). And they were imported as regular scripts and not as modules.

*What is the difference between module and regular script? Most important differences are that it has a lexical top-level scope (a variable declared in the module scope is not reachable from the global scope, as it would be the case with a regular script), `this` doesn’t refer to the global `this` (but to `undefined`), and of course the support of `import` and `export` syntaxe.*

On the other hand, front-end frameworks have been supplying module system for long time :
 - with their own system before ES6 (ex: Angular JS scope and dependency injection)
 - with ES6 modules after 2015.

Therefore, **bundlers**, which could understand a module system and compile it into a browser-understandable script, **were the best (only) solution, even for development servers**. But, as we will see right after, **browsers now support the same module system** than most of JavScript frameworks, which gives **much more options**, at least for dev servers.

<br/>

#### Browser static modules implementation:
<br/>
But, since 2018, all major browsers support ES modules. 

This means that now browsers expose ways of importing modules: 

 - with the script tag: we inform the browser that the script loaded is a module giving the **“module” value to the `type` attribute**. This is generally used for importing entry points:
```
<script type="module" src="./main.js"></script>
```

 - with the `import` syntax:
```
import App from “/js/app.js"
```

As with the `script` tag, this triggers an **HTTP request** to load the file `app.js`, which will be by default treated as a module - so in particular it can itself import modules. We can then import easily nested dependencies, which will be loaded layer by layer.

*Nb: as soon as there are few layers of dependencies, module imports can lead to cascade of HTTP requests. Therefore, this **not suitable for production** (for more details on module imports vs bundling you can have a look on [this (src: Google V8)](https://v8.dev/features/modules#performance) )*

An other important specificity of the browser `import` implementation is the module specifier (the module path module): it must be an URL, **bare imports are not supported**.

Then, the browser works like a module handler: any new module is added to a dictionary (a Map) and keyed with its URL. So **any module is imported only once** because, if it is required twice, the browser recognize its specifier and gets it from its storage. These details will be useful to understand how Vite browser updates work.

Then, when all the whole dependency graph has been loaded, modules are instantiated (from the most nested to the top), their exports are made available, and only then the main code will be executed.

<br/>

#### Browser dynamic modules implementation:
<br/>
In accordance with ES6 modules spec, browsers also implement the `import()` method which enables dynamic imports - this method is asynchronous and returns a promise. Dynamically imported modules are added to the module Map, and are treated as regular modules. As we will see, Vite relies on this feature for updates.

So we have seen now that browser and Vue apps share the same module system (with different implementations; we will see now how Vite takes advantage of this.
